# 单链表（链式存储结构）及创建
---
> 链表，别名链式存储结构或单链表，用于存储逻辑关系为 "一对一" 的数据。与顺序表不同，链表不限制数据的物理存储状态，换句话说，使用链表存储的数据元素，其物理存储位置是随机的。

例如，使用链表存储 {1,2,3}，数据的物理存储状态如下图所示：

<image src="./images/image01.gif" width="60%"/>

我们看到，上图根本无法体现出各数据之间的逻辑关系。对此，链表的解决方案是，每个数据元素在存储时都配备一个指针，用于指向自己的直接后继元素。如下图所示：

<image src="./images/image02.gif" width="60%"/>

像上面所展示的，数据元素随机存储，并通过指针表示数据之间逻辑关系的存储结构就是链式存储结构。

---
## 链表的节点

从上面所提到的以及所展示的图片可以看到，链表中每个数据的存储都由以下两部分组成：
- 数据元素本身，其所在的区域称为数据域；
- 指向直接后继元素的指针，所在的区域称为指针域；

即单链表中存储各数据元素的结构如下图所示：

<image src="./images/image03.gif"/>

上图所示的结构在链表中称为节点。也就是说，链表实际存储的是一个一个的节点，真正的数据元素包含在这些节点中，如下图所示：

<image src="./images/image04.gif"/>

因此，链表中每个节点的具体实现，需要使用 C 语言中的结构体，具体实现代码为：
```C
/**
 *  链表节点的结构体
 * 
 *  - ElemType elem 数据域
 *  - struct Link *next 指针域，指向直接后的节点
 */ 
typedef struct Link{
    ElemType elem;
    struct Link *next;
} link;
```
> 由于指针域中的指针要指向的也是一个节点，因此要声明为 Link 类型（这里要写成 $struct\quad Link$ 的形式）。

---
## 头节点，头指针和首元节点

一个完整的链表需要由以下几部分构成：

1. 头指针：一个普通的指针，它的特点是永远指向链表第一个节点的位置。很明显，头指针用于指明链表的位置，便于后期找到链表并使用表中的数据；
2. 节点：链表中的节点又细分为头节点、首元节点和其他节点：
 
   - 头节点：其实就是一个不存任何数据的空节点，通常作为链表的第一个节点。对于链表来说，头节点不是必须的，它的作用只是为了方便解决某些实际问题；
   - 首元节点：由于头节点（也就是空节点）的缘故，链表中称第一个存有数据的节点为首元节点。首元节点只是对链表中第一个存有数据节点的一个称谓，没有实际意义；
   - 其他节点：链表中其他的节点；

因此，一个存储 {1,2,3} 的完整链表结构如下图所示：

<image src="./images/image05.gif" width="80%"/>

> 注意：链表中有头节点时，头指针指向头节点；反之，若链表中没有头节点，则头指针指向首元节点。

现在我们明白了链表的基本结构，那么就可以开始进行单链表的创建了。

----
## 单链表的创建

在我看来单链表的创建实质是节点的创建，因为我们创建节点之后就可以再将这个节点与之前的链表连接便可。

初始化节点的代码如下（C语言）：
```C
/**
 *  初始化链表节点
 *  - link *    返回创建的节点的地址
 *  - ElemType elem 传入该节点所需要存放的值
 */
link *initLinkNode(ElemType elem)
{
    link *node = (link *)malloc(sizeof(link));
    node->elem = elem;
    node->next = NULL;
    return node;
}
```

然后我们便可以在主函数内使用该函数，创建一个单链表，并进行输出，为了方便调用输出，我们编写一个输出函数，代码如下：
```C
void displayLink(link *L)
{
    link *temp = L;
    temp = L->next;
    for (int i = 1; i < 5; i++)
    {
        printf("%d  ", temp->elem);
        temp = temp->next;
    }
}
```
同时，我们考虑到初始化的时候我们可能会有一堆初始数据，如果我们手动的一个数据一个数据输入，肯定是极其不合理的，所以我们编写了一个创建部分链表的函数，它接受两个参数，一个是初始数据，使用数组存放，另一个就是数据的数量，具体C语言代码如下：
```C
/**
 * 初始化链表函数：可以直接初始化一堆数据
 * 
 *  - ElemType data[]  初始化数据所存储的数组
 *  - int length    数据量
 */ 
link *initLink(ElemType data[], int length)
{
    link *start, *end;
    start = initLinkNode(data[0]);
    end = start;
    for (int i = 1; i < length; i++)
    {
        link *node = initLinkNode(data[i]);
        end->next = node;
        end = node;
    }
    return start;
}
```

main函数代码如下：

```C
int main()
{
    link *head;
    head = initLinkNode(0);
    int data[] = {11, 22, 33, 44, 55, 66, 77};
    int length = 7;
    head->next = initLink(data, length);
    displayLink(head);
    system("pause");
    return 0;
}
```
如果你仔细看 $main$函数 的代码，你就会发现，我们在main函数中创建的链表是带头结点的，以上我们就完成了单链表的初始化工作。

---
## 链表插入元素
同顺序表一样，向链表中增添元素，根据添加位置不同，可分为以下 3 种情况：
- 插入到链表的头部（头节点之后），作为首元节点；
- 插入到链表中间的某个位置；
- 插入到链表的最末端，作为链表中最后一个数据元素；

虽然新元素的插入位置不固定，但是链表插入元素的思想是固定的，只需做以下两步操作，即可将新元素插入到指定的位置：
1. 将新结点的 next 指针指向插入位置后的结点；
2. 将插入位置前结点的 next 指针指向插入结点；

例如，我们在链表 {1,2,3,4} 的基础上分别实现在头部、中间部位、尾部插入新元素 5，其实现过程如下图所示：

<image src="./images/image06.gif" width="60%">

从图中可以看出，虽然新元素的插入位置不同，但实现插入操作的方法是一致的，都是先执行步骤 1 ，再执行步骤 2。

> 注意：链表插入元素的操作必须是先步骤 1，再步骤 2；反之，若先执行步骤 2，会导致插入位置后续的部分链表丢失，无法再实现步骤 1。

通过上面的描述，我们可以开始尝试编写单链表的插入函数：

```C
/**
 *  插入函数
 *  - link *L   要插入的链表
 *  - ElemType elem 要插入的元素
 *  - int site  要插入的位置
 *  注意：链表带有一个空的头指针
 */
void insertLink(link *head, ElemType elem, int site)
{
    link *temp;
    temp = head;
    for (int i = 0; i < site - 1; i++)
    {
        if (temp == NULL)
        {
            printf("插入位置错误，请重新插入！\n");
            return;
        }
        temp = temp->next;
    }
    link *node = initLinkNode(elem);
    node->next = temp->next;
    temp->next = node;
}
```
> 当插入的位置超出了链表的长度时，便会进入if中，然后就会打印提示信息并返回。

---
## 链表删除元素

从链表中删除指定数据元素时，实则就是将存有该数据元素的节点从链表中摘除，但作为一名合格的程序员，要对存储空间负责，对不再利用的存储空间要及时释放（当然现在很多语言都是有自己的垃圾回收机制，或许我们都不用再担心是否会有内存没释放，但是对于C语言来说，这是不可少的）。因此，从链表中删除数据元素需要进行以下 2 步操作：
- 将结点从链表中摘下来;
- 手动释放掉结点，回收被结点占用的存储空间;

其实，从链表上删除节点非常简单，只需找到该节点的直接前驱节点，执行下面的语句便行：
```C
temp->next=temp->next->next;
```

例如，从存有 {1,2,3,4} 的链表中删除元素 3，则上面代码执行效果如下图所示：

<image src="./images/image06.gif" width="60%"/>

C语言实现删除链表中的元素如下：

```C
/**
 *  删除函数
 *  - link *L   要操作的链表
 *  - int site  要删除的位置
 *  注意：链表带有一个空的头指针
 */
void deleteLink(link *head, int site)
{
    link *temp,*del;
    temp = head;
    for (int i = 0; i < site - 1; i++)
    {
        if (temp == NULL)
        {
            printf("插入位置错误，请重新插入！\n");
            return;
        }
        temp = temp->next;
    }
    del = temp->next;
    temp->next = temp->next->next;
    free(del);
}
```
> 在上面，我们通过free()函数手动释放内存。

## 链表查找元素

在链表中查找指定数据元素，最常用的方法是：从表头依次遍历表中节点，用被查找元素与各节点数据域中存储的数据元素进行比对，直至比对成功或遍历至链表最末端的 NULL（比对失败的标志）。

C语言代码如下：

```C
/**
 *  查询函数
 *  - link *L   要操作的链表
 *  - ElemType elem 要查询的元素
 *  注意：链表带有一个空的头指针
 */
int selectLink(link *head, ElemType elem)
{
    link *temp;
    int i = 1;
    temp = head->next;
    while (temp)
    {
        if (temp->elem == elem)
        {
            return i;
        }
        temp = temp->next;
        i++;
    }
    return -1;
}
```

---
## 链表更新元素

更新链表中的元素，只需通过遍历找到存储此元素的节点，对节点中的数据域做更改操作即可。

C语言代码如下：

```C
/**
 *  修改函数
 *  - link *L   要操作的链表
 *  - ElemType elem 要修改的目标值
 *  - int site  要修改的位置
 *  注意：链表带有一个空的头指针
 */
void amendLink(link *head, ElemType newElem, int site)
{
    link *temp;
    temp = head;
    for (int i = 0; i < site; i++)
    {
        if (temp == NULL)
        {
            printf("插入位置错误，请重新插入！\n");
            return;
        }
        temp = temp->next;
    }
    temp->elem = newElem;
}
```

---
> 到这里，单链表所有操作我们都完成了，完整代码在code文件下，请需要者自取。

# 顺序表（顺序存储结构）及初始化过程详解

- 顺序表，全名顺序存储结构，是线性表的一种。线性表用于存储逻辑关系为“一对一”的数据，顺序表自然也不例外。

- 不仅如此，顺序表对数据的物理存储结构也有要求。顺序表存储数据时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，存储时做到数据元素之间不留一丝缝隙。

例如，使用顺序表存储集合 {1,2,3,4,5}，数据最终的存储状态下图所示：
<image src="./images/image01.gif" width="60%"/>

从上面我们可以得出：
- 将“具有 '一对一' 逻辑关系的数据按照次序连续存储到一整块物理空间上”的存储结构就是顺序存储结构。

同时我们通过观察可以发现顺序表和数组十分接近，实质上顺序表也就是利用数组进行实现的。

---
## 定义顺序表的结构

使用顺序表存储数据之前，除了要申请足够大小的物理空间之外，为了方便后期使用表中的数据，顺序表还需要实时记录以下 2 项数据：
- 顺序表申请的存储容量；
- 顺序表的长度，也就是表中存储数据元素的个数；

> 在正常情况下，顺序表申请的存储容量要大于它的长度

因此，我们可以自定义顺序表如下（以C语言为例）：
```C
    typedef struct SqList{
        // ElemType 是我们定义的数据类型
        ElemType *head; // 声明一个名为head的不确定长度的数组，也叫动态数组
        int length; // 记录当前顺序表的长度
        int size; // 记录顺序表的分配的存储容量
    }sqlist;
```
>在这里，我们应该将 head 看作是一个未初始化的动态数组，不要只把它看做是普通的指针。

---
## 顺序表的初始化

接下来我们就开始进行顺序表的初始化，首先我们应该要明确初始化顺序表所要做的工作：

- 给 head 动态数据申请足够大小的物理空间；
- 给 length 和 size 赋值；

下面以C语言为例：
```C
    #define MAXSIZE 100
    typedef int ElemType;

    void initSqList(sqlist *sq){
        sq.head = (ElemType*)malloc(MAXSIZE*sizeof(ElemType)); // 构造一个空的顺序表，动态申请存储空间
        if(!sq.head){
            printf("顺序表初始化失败");
            exit(0);
        }
        sq.length = 0;
        sq.size = MAXSIZE;
    }
```
除了上面初始化的方法，还存在一种方法，也就是我们刚才所说的，顺序表的实质看起来就像一个数组，所以，我们也可以使用数组对其进行初始化,代码如下:

```C
    #define MAXSIZE 100
    typedef int ElemType;

    void initSqList(sqlist *sq){
        sq->head = new ElemType[MAXSIZE]; // 构造一个空的顺序表，动态申请存储空间
        if(!sq->head){
            printf("顺序表初始化失败");
            exit(0);
        }
        sq->length = 0;
        sq->size = MAXSIZE;
    }
```
上面两种方法的任意一种都可以对顺序表进行初始化。

---
## 顺序表的插入

向已有顺序表中插入数据元素，根据插入位置的不同，可分为以下 3 种情况：
- 插入到顺序表的表头；
- 在表的中间位置插入元素；
- 尾随顺序表中已有元素，作为顺序表中的最后一个元素；

虽然数据元素插入顺序表中的位置有所不同，但是都使用的是同一种方式去解决，即：通过遍历，找到数据元素要插入的位置，然后做如下两步工作：
1. 将要插入位置元素以及后续的元素整体向后移动一个位置；
2. 将元素放到腾出来的位置上；

例如，在 {1,2,3,4,5} 的第 3 个位置上插入元素 6，实现过程如下：
- 遍历至顺序表存储第 3 个数据元素的位置，如下图所示：
<image src="./images/image02.gif" width="60%"/>
- 将元素 3 以及后续元素 4 和 5 整体向后移动一个位置，如图所示：
<image src="./images/image03.gif" width="60%"/>
- 将新元素 6 放入腾出的位置，如图所示：
<image src="./images/image04.gif" width="60%"/>

当我们了解插入原理之后就能开始编写插入函数代码了，C语言代码如下：
```C
    /**
 *  插入函数：向顺序表指定位置插入元素
 *  -   sqlist *sq  插入的顺序表
 *  -   int index   插入的位置（不是下标，下标从0开始，这是从1开始）
 *  -   ElemType num 插入的元素
 */
void insertSqList(sqlist *sq, int index, ElemType num)
{
    if (index > sq->length || index < 1)
    {
        printf("索引错误，请输入合法索引！");
        return;
    }
    for (int i = sq->length; i >= index; i--)
    {
        sq->head[i] = sq->head[i - 1];
    }
    sq->head[index - 1] = num;
    sq->length++;
}
```
> 注意：
> - 在实现后续元素整体后移的过程，目标位置其实是有数据的，还是 3，只是下一步新插入元素时会把旧元素直接覆盖。
> - 在插入元素时记得将顺序表长度加一，否则最后那个元素就无法输出

---
## 顺序表删除元素

从顺序表中删除指定元素，实现起来很简单，只需要找到目标元素，并将其后续所有元素整体前移 1 个位置即可。

> 需要注意的是，在向前移动一个位置之后应该对顺序表长度减一

例如，从 {1,2,3,4,5} 中删除元素 3 的过程如下图所示：
<image src="./images/image05.gif" width="60%">

顺序表删除元素的C语言代码如下所示：
```C
/**
 *  删除函数：在顺序表指定位置删除元素
 *  - sqlist *sq    传入顺序表的地址
 *  -   int index   传入要删除的位置
 */
void deleteSqList(sqlist *sq, int index)
{
    if (index > sq->length || index < 1)
    {
        printf("索引错误，请输入合法索引！");
        return;
    }
    for (int i = index; i < sq->length; i++)
    {
        sq->head[i - 1] = sq->head[i];
    }
    sq->length--;
}
```

## 顺序表查找元素

在个人看来，顺序表查找元素完全是没有困难的，因为我们如果按照下标查找元素我们也就不用单独写一个函数，如果是查找一个与给的元素相等的元素，那么只需要找到就行，返回其所在的位置即可。不用去考虑顺序表中是否还存在其他相等的元素。

除此外，我们的顺序表一开始也没有做排序，所以也不能使用二分法查找，这样的话就是直接顺序查找。

C语言代码如下：
```C
/**
 *  查找元素：从顺序表查找指定元素，并返回下标
 *  -   ElemType elem  需要查找的元素
 *  查到返回元素所在的位置，否则返回 -1
 */
int selectSqList(sqlist sq, ElemType elem)
{
    for (int i = 0; i < sq.length; i++)
    {
        if (elem == sq.head[i])
        {
            return i + 1;
        }
    }
    return -1;
}
```
---
## 顺序表更改元素

在我看来，在顺序表中实现更改元素是没有意义的，如果是按下标或者位置修改，直接就可以通过索引更改，如果是将顺序表中的某个指定的值全部修改为替换值，那便是遍历顺序表。

下面我将给出将顺序表中的所有指定的元素修改为替换值的C语言代码：
```C
/**
 *  修改函数：修改顺序表中指定的元素
 *  - ElemType begindata 需要修改的元素
 *  - ElemType amenddata 修改的结果
 */ 
void amendSqList(sqlist *sq, ElemType begindata, ElemType amenddata)
{
    for (int i = 0; i < sq->length; i++)
    {
        if (sq->head[i] == begindata)
        {
            sq->head[i] = amenddata;
        }
    }
}
```
---
>到这里，顺序表的实现就完成了，接下来，我们就开始实现链表
